---
layout: post
title: How-To Ban Git Merge Commits
baseline: Banning git merge commits in closed-source projects is all the rage. How can you actually enforce it?
credit: 'Image generated by FLUX.1 [dev] with prompt “abstract illustration of a minimal simple Sankey diagram of a timeline from left to right with a couple of lines splitting off and merging back into each other”'
splash: media/abstract-illustration-of-a-minimal-sankey-diagram-of-a-timeline.jpg
category: blog
published: true
tags: [git, rebase, merge-commits, atomic-commits]
---

I hate noise in my git history and useless `git blame` identifiers with the heat of a thousand suns. I’ve felt somewhat embarassed and self-conscious about this fact, because it is [yet](https://acusti.ca/blog/2014/11/28/towards-a-more-perfect-link-underline/) [another](https://acusti.ca/blog/2025/01/13/eslint-plugin-import-with-yarn-pnp/) symptom of my overbearing perfectionist inclinations. However, I then came across a blog post called [“Why large companies and fast-moving startups are banning merge commits”][] by Greg Foster, and saw that this is a more common practice than I had thought.

A quick summary of why: banning merge commits creates a cleaner, more understandable history, and rebasing makes it much easier to cleanly revert a set of changes, especially when you also get your team making [atomic commits][]. The symbiosis between banning merge commits and practicing atomic commits is very powerful: as Frederick Vanbrabant argues above, atomic commits are about “Telling stories with Git”. Why was this change made/created, and what was being considered as a part of that process? If it is causing a bug for customers, will changing it break something else and cause a regression? This is incredibly important data when maintaining and improving a codebase, so I strive to preserve it and make it as accessible as possible to future developers (including myself) tasked with that work.

So, how do you actually enforce this policy? There are a few git config settings that make this possible. First, make sure that when you pull updates to a branch, you tell git to rebase your un-pushed commits on top of any commits pulled down from the remote that you didn’t already have locally:

```bash
git config --global pull.rebase true
```

I personally believe that anyone who is generally comfortable with the notion of rebasing should set this option, not just people who want to ban merge commits in their codebase. Collaborating on a branch without this setting quickly becomes comically messy and noisy. Note that in older versions of git (pre v1.7.9), you could accomplish something similar with `git config --global branch.autosetuprebase always`, though that option only applies to newly created branches.

The next config is a little more opinionated and has the potential to cause frustration, especially for those with poor git hygiene:

```bash
git config --global merge.ff only
```

That’s because it tells git to only perform fast-forward merges, which means that if you have a branch that has diverged from the branch you’re trying to merge into, git will refuse to merge the branches together. This is a good thing, because it forces you to rebase your branch on top of the branch you’re trying to merge into, which keeps the history clean and linear. However, if you’re not in the habit of rebasing, this can be a frustrating experience, as you’ll have to rebase your branch every time you want to merge it into another branch.

The `merge.ff only` config option has a sibling for the `git pull` command:

```bash
git config --global pull.ff only
```

This makes it so that in the case of a pull that can’t be done as a fast-forward (e.g. if there are remote commits you don’t have locally and you have local commits that haven’t been pushed up), the pull will fail. However, in that situation, the `pull.rebase true` config option will ensure that you do a rebase, not a fast-forward merge, so there will be no merge for this setting to affect. The one edge case where it could do something is if you explicitly override the `pull.rebase` setting with `git pull --no-rebase`, but if you are explicitly telling git not to rebase, you are most likely doing it for a reason, so having the pull still fail because of this setting would probably be frustrating and unwanted. As a result, I don’t use this in my own gitconfig.

That’s how I do it! The trouble with this approach is that there’s no way to set git config options on a repository so that anyone who clones it gets that config, which is a limitation that exists for security reasons; gitconfig files can run arbitrary CLI commands, so you might unwittingly kick-off a key logger or any other malicious code when running, say, `git commit`, if the repo owner set up the gitconfig to do so. As a result, you have to add the instructions to your README or other documentation and rely on socialization to ensure that everyone on your team is on the same page.

[“Why large companies and fast-moving startups are banning merge commits”]: https://graphite.dev/blog/why-ban-merge-commits
[atomic commits]: https://frederickvanbrabant.com/blog/2017-12-7-atomic-commits/
